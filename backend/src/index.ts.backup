import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import dotenv from 'dotenv';
import { createLogger } from './utils/logger';
import { DatabaseService } from './services/database.service';

dotenv.config();

const app = express();
const port = process.env.BACKEND_PORT || 3001;
const logger = createLogger();
const dbService = new DatabaseService();

dbService.connect().catch(err => logger.error('DB connection failed:', err));

app.use(helmet());
app.use(cors());
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

app.use('/api/chat', require('./api/routes/chat').default);

app.get('/api/conversations', async (req: express.Request, res: express.Response): Promise<void> => {
  try {
    const conversations = await dbService.getConversations();
    res.json({ conversations });
  } catch (error) {
    logger.error('Error fetching conversations:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

app.post('/api/conversations', async (req: express.Request, res: express.Response): Promise<void> => {
  try {
    const { title, project_id } = req.body;
    const conversation = await dbService.createConversation(title || 'New Conversation', project_id);
    res.json(conversation);
  } catch (error) {
    logger.error('Error creating conversation:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

app.post('/api/conversations/:id/messages', async (req: express.Request, res: express.Response): Promise<void> => {
  try {
    const conversationId = req.params.id;
    const { content } = req.body;

    if (!content) {
      res.status(400).json({ error: 'Message content required' });
      return;
    }

    const userMessage = await dbService.addMessage(conversationId, 'user', content);
    const recentMessages = await dbService.getMessages(conversationId, 5);
    
    const claudeMessages = recentMessages.map(msg => ({
      role: msg.role as 'user' | 'assistant',
      content: msg.content
    }));

    const { ClaudeService } = require('./services/claude.service');
    const claudeService = new ClaudeService();
    const claudeResponse = await claudeService.sendMessage(claudeMessages);
    const assistantContent = claudeResponse.content[0]?.text || 'Sorry, could not generate response.';

    const assistantMessage = await dbService.addMessage(conversationId, 'assistant', assistantContent, { 
      model: claudeResponse.model,
      usage: claudeResponse.usage 
    });

    res.json({
      user_message: userMessage,
      assistant_message: assistantMessage,
      usage: claudeResponse.usage
    });

  } catch (error) {
    logger.error('Error processing message:', error);
    res.status(500).json({ error: 'Failed to process message' });
  }
});

app.get('/api/health', async (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV
  });
});

app.get('/api/info', (req, res) => {
  res.json({
    name: 'Claude Infinito v1.1 Backend',
    version: '1.1.0'
  });
});

app.get('/', (req, res) => {
  res.json({ 
    message: 'Claude Infinito v1.1 Backend', 
    status: 'running'
  });
});

app.listen(port, () => {
  logger.info(`Backend running on port ${port}`);
});

export default app;
