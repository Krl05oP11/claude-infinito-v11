import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import dotenv from 'dotenv';
import { createLogger } from './utils/logger';
import { DatabaseService } from './services/database.service';
import { RAGService } from './services/rag.service';
import uploadRoutes from './api/routes/upload';

dotenv.config();

const app = express();
const port = process.env.BACKEND_PORT || 3001;
const logger = createLogger();
const dbService = new DatabaseService();
const ragService = new RAGService();

// Connect to database
dbService.connect().catch(err => logger.error('DB connection failed:', err));

// Middleware
app.use(helmet());
app.use(cors());
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

app.use('/api/upload', uploadRoutes);

// Chat routes
app.use('/api/chat', require('./api/routes/chat').default);

// Conversations endpoints
app.get('/api/conversations', async (req: express.Request, res: express.Response): Promise<void> => {
  try {
    const conversations = await dbService.getConversations();
    res.json({ conversations });
  } catch (error) {
    logger.error('Error fetching conversations:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

app.post('/api/conversations', async (req: express.Request, res: express.Response): Promise<void> => {
  try {
    const { title, project_id } = req.body;
    const conversation = await dbService.createConversation(title || 'New Conversation', project_id);
    res.json(conversation);
  } catch (error) {
    logger.error('Error creating conversation:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

// Helper function to detect if this is a file-related question
function isFileRelatedQuestion(content: string): boolean {
  const fileKeywords = ['archivo', 'libro', 'pdf', 'documento', 'text', 'file', 'sub√≠', 'uploaded', 'cap√≠tulo', 'p√°gina'];
  const lowerContent = content.toLowerCase();
  return fileKeywords.some(keyword => lowerContent.includes(keyword));
}

// Helper function to extract keywords from question for context filtering
function extractQuestionKeywords(content: string): string[] {
  // Stop words expandidos - palabras que NO queremos como keywords
  const stopWords = [
    // Espa√±ol b√°sico
    'que', 'qu√©', 'el', 'la', 'de', 'en', 'y', 'a', 'un', 'una', 'es', 'se', 'no', 'te', 'lo', 'le', 'da', 'su', 'por', 'son', 'con', 'para', 'como', 'pero', 'sus', 'del', 'las', 'los', 'una', 'este', 'esta', 'estos', 'estas', 'ese', 'esa', 'esos', 'esas', 
    'desde', 'hasta', 'cuando', 'donde', 'quien', 'cual', 'cuales', 'muy', 'm√°s', 'menos', 'tambi√©n', 'tan', 'tanto', 'toda', 'todo', 'todos', 'todas',
    'me', 'mi', 'mis', 'nos', 'nuestro', 'nuestra', 'nuestros', 'nuestras',
    'ser', 'estar', 'tener', 'hacer', 'poder', 'decir', 'ir', 'ver', 'dar', 'saber', 'querer', 'llegar', 'poner', 'parecer', 'seguir', 'encontrar', 'llamar', 'venir', 'pensar', 'salir', 'volver', 'tomar', 'conocer', 'vivir', 'sentir', 'tratar', 'dejar', 'llevar',
    
    // Palabras gen√©ricas de conversaci√≥n
    'hola', 'claude', 'resume', 'resumen', 'unas', 'pocas', 'l√≠neas', 'cu√°les', 'ventajas', 'debes', 'debe', 'debo', 'tener', 'acceso', 'collection', 'subido', 'subida',
    
    // English b√°sico
    'the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'man', 'new', 'now', 'old', 'see', 'two', 'way', 'who', 'boy', 'did', 'its', 'let', 'put', 'say', 'she', 'too', 'use'
  ];
  
  // Palabras clave importantes que siempre queremos preservar
  const importantKeywords = [
    // Autores y nombres propios
    'mitchell', 'melanie', 'darwin', 'holland', 'goldberg', 'koza', 'fogel',
    
    // T√©rminos t√©cnicos de algoritmos gen√©ticos
    'algoritmos', 'gen√©ticos', 'genetic', 'algorithm', 'algorithms',
    'fitness', 'selecci√≥n', 'selection', 'mutaci√≥n', 'mutation', 'crossover', 'cruzamiento',
    'poblaci√≥n', 'population', 'generaci√≥n', 'generation', 'cromosoma', 'chromosome',
    'evoluci√≥n', 'evolution', 'adaptaci√≥n', 'adaptation', 'supervivencia', 'survival',
    
    // T√©rminos de machine learning
    'machine', 'learning', 'aprendizaje', 'autom√°tico', 'inteligencia', 'artificial',
    'clustering', 'clasificaci√≥n', 'regresi√≥n', 'neural', 'redes', 'networks',
    'elbow', 'method', 'm√©todo', 'codo', 'kmeans', 'svm', 'bayes',
    
    // T√©rminos de documentos
    'libro', 'cap√≠tulo', 'p√°gina', 'secci√≥n', 'documento', 'archivo', 'pdf', 'text',
    'paper', 'art√≠culo', 'investigaci√≥n', 'estudio', 'an√°lisis',
    
    // Conceptos espec√≠ficos
    'optimizaci√≥n', 'optimization', 'b√∫squeda', 'search', 'heur√≠stica', 'heuristic',
    'convergencia', 'convergence', 'diversidad', 'diversity', 'exploraci√≥n', 'exploration',
    'explotaci√≥n', 'exploitation', 'par√°metros', 'parameters'
  ];
  
  // Limpiar y procesar el contenido
  const words = content
    .toLowerCase()
    .replace(/[^\w\s√°√©√≠√≥√∫√±√º]/g, ' ') // Preservar caracteres espa√±oles
    .split(/\s+/)
    .filter(word => word.length > 2); // M√≠nimo 3 caracteres
  
  // Extraer keywords con priorizaci√≥n inteligente
  const extractedKeywords: string[] = [];
  
  // 1. Primero: palabras importantes identificadas espec√≠ficamente
  words.forEach(word => {
    if (importantKeywords.includes(word) && !extractedKeywords.includes(word)) {
      extractedKeywords.push(word);
    }
  });
  
  // 2. Segundo: sustantivos t√©cnicos que no est√°n en stop words
  words.forEach(word => {
    if (word.length >= 4 && 
        !stopWords.includes(word) && 
        !importantKeywords.includes(word) &&
        !extractedKeywords.includes(word) &&
        extractedKeywords.length < 8) { // L√≠mite total de 8 keywords
      
      // Priorizar palabras que parecen t√©cnicas o espec√≠ficas
      if (word.includes('tion') || word.includes('sion') || word.includes('ci√≥n') ||
          word.includes('ment') || word.includes('ness') || word.includes('ismo') ||
          word.includes('idad') || word.includes('encia') || word.includes('ancia')) {
        extractedKeywords.push(word);
      }
    }
  });
  
  // 3. Tercero: otras palabras relevantes si a√∫n necesitamos m√°s
  if (extractedKeywords.length < 5) {
    words.forEach(word => {
      if (word.length >= 4 && 
          !stopWords.includes(word) && 
          !extractedKeywords.includes(word) &&
          extractedKeywords.length < 8) {
        extractedKeywords.push(word);
      }
    });
  }
  
  return extractedKeywords.slice(0, 8); // M√°ximo 8 keywords
}
// Messages endpoint with RAG integration and DYNAMIC CONFIGURATION SUPPORT
app.post('/api/conversations/:id/messages', async (req: express.Request, res: express.Response): Promise<void> => {
  try {
    const conversationId = req.params.id;
    const { content, settings } = req.body; // ‚úÖ ADDED: settings support

    if (!content) {
      res.status(400).json({ error: 'Message content required' });
      return;
    }

    // ‚úÖ NEW: Extract and validate dynamic settings
    const claudeSettings = settings || {};
    
    logger.info(`Processing message for conversation ${conversationId}`);
    if (settings) {
      logger.info(`Using dynamic settings: temp=${claudeSettings.temperature || 'default'}, promptType=${claudeSettings.promptType || 'none'}`);
    }

    // 1. Save user message
    const userMessage = await dbService.addMessage(conversationId, 'user', content);
    
    // 2. Get recent messages from current conversation
    const recentMessages = await dbService.getMessages(conversationId, 10); // Increased to better detect context
    
    // 3. Get conversation info to determine current project
    const conversation = await dbService.getConversationById(conversationId);
    const currentProjectId = conversation?.project_id || conversationId;
    
    // 4. Smart context detection: Analyze conversation history for file context
    const isCurrentFileQuestion = isFileRelatedQuestion(content);
    const previousFileQuestions = recentMessages.filter(msg => 
      msg.role === 'user' && isFileRelatedQuestion(msg.content)
    ).length;
    
    const hasEstablishedFileContext = previousFileQuestions > 0;
    const isFirstFileQuestion = previousFileQuestions <= 1 && isCurrentFileQuestion;
    
    logger.info(`Context Analysis: isFileQuestion=${isCurrentFileQuestion}, previousFileQuestions=${previousFileQuestions}, hasEstablishedContext=${hasEstablishedFileContext}, isFirstFileQuestion=${isFirstFileQuestion}`);
    
    // 5. Initialize variables for RAG
    let relevantMemories: any[] = [];
    let contextualMemory: string = '';
    let contextStrategy: string = 'none';
    
    // 6. Search for semantic context with INTELLIGENT STRATEGY
    try {
      if (isCurrentFileQuestion) {
        logger.info('Searching for relevant context across all projects...');
        console.log('üöÄ CALLING searchAllProjects...');
        const allMemories = await ragService.searchAllProjects(content, 20);
        console.log('üöÄ searchAllProjects RETURNED:', allMemories.length, 'memories');

        if (allMemories.length > 0) {
          logger.info(`Found ${allMemories.length} total memories across all projects`);
          
          // Separate current project from other projects
          const currentProjectMemories = allMemories.filter(memory => {
            const memoryProjectId = memory.metadata?.project_id || memory.metadata?.conversation_id;
            return memoryProjectId === currentProjectId;
          });
          
          const otherProjectsMemories = allMemories.filter(memory => {
            const memoryProjectId = memory.metadata?.project_id || memory.metadata?.conversation_id;
            return memoryProjectId !== currentProjectId;
          });
          
          logger.info(`Found ${currentProjectMemories.length} memories in CURRENT project`);
          logger.info(`Found ${otherProjectsMemories.length} memories in OTHER projects`);
          
          // PRIORITIZATION LOGIC: Current project FIRST
          let finalMemories: any[] = [];
          
          if (currentProjectMemories.length > 0) {
            finalMemories = [...currentProjectMemories.slice(0, 12)];
            const remainingSlots = Math.max(15 - finalMemories.length, 0);
            if (remainingSlots > 0 && otherProjectsMemories.length > 0) {
              finalMemories = [...finalMemories, ...otherProjectsMemories.slice(0, Math.min(3, remainingSlots))];
            }
            logger.info(`PRIORITIZED: ${currentProjectMemories.length} from current project, ${Math.min(3, Math.max(15 - currentProjectMemories.slice(0, 12).length, 0))} from other projects`);
          } else {
            finalMemories = otherProjectsMemories.slice(0, 15);
            logger.info(`FALLBACK: Using ${finalMemories.length} memories from other projects`);
          }
          
          relevantMemories = finalMemories;
          
          // SMART CONTEXT FILTERING: Filter by question relevance for subsequent questions
          if (hasEstablishedFileContext && !isFirstFileQuestion) {
            const questionKeywords = extractQuestionKeywords(content);
            logger.info(`FILTERING by keywords: ${questionKeywords.join(', ')}`);
            
            // Filter memories by relevance to specific question
          const keywordFilteredMemories = relevantMemories.filter(memory => {
            // ‚úÖ PRESERVE ALL FILES regardless of keywords
            const isFile = memory.metadata?.source_type === 'file_upload' || 
                           memory.metadata?.file_name || 
                           memory.metadata?.filename ||
                           memory.metadata?.fileType;
  
            if (isFile) {
              console.log('üîç PRESERVING FILE:', memory.metadata?.file_name || 'unknown_file');
              return true; // Always keep files
            }
  
            // Filter conversations by keywords
            const memoryText = memory.content.toLowerCase();
            const hasKeywords = questionKeywords.some(keyword => memoryText.includes(keyword));
  
            if (hasKeywords) {
              console.log('üîç KEEPING CONVERSATION by keywords');
            }
  
            return hasKeywords;
          });            
            if (keywordFilteredMemories.length > 0) {
              relevantMemories = keywordFilteredMemories.slice(0, 8); // Reduced for focused context
              contextStrategy = 'filtered';
              logger.info(`FILTERED to ${relevantMemories.length} relevant memories for specific question`);
            } else {
              relevantMemories = relevantMemories.slice(0, 5); // Even more reduced if no keyword matches
              contextStrategy = 'minimal';
              logger.info(`No keyword matches, using minimal context (${relevantMemories.length} memories)`);
            }
          } else {
            contextStrategy = isFirstFileQuestion ? 'full' : 'standard';
          }
          
          // Separate file content from conversation history
          const fileMemories = relevantMemories.filter(memory => {
          const sourceType = memory.metadata?.source_type;
          const fileName = memory.metadata?.file_name || memory.metadata?.filename;
          const fileType = memory.metadata?.fileType;
          const isFile = sourceType === 'file_upload' || fileName || fileType;
  
          // üîç DEBUG FILTRADO
          console.log('üîç FILTERING DEBUG:', {
            sourceType,
            fileName, 
            fileType,
            isFile,
            fullMetadata: memory.metadata
          });
  
          return isFile;
        });          
          const conversationMemories = relevantMemories.filter(memory => {
            const sourceType = memory.metadata?.source_type;
            const fileName = memory.metadata?.file_name || memory.metadata?.filename;
            const fileType = memory.metadata?.fileType;
            return !(sourceType === 'file_upload' || fileName || fileType);
          });
          
          logger.info(`Found ${fileMemories.length} file memories`);
          logger.info(`Found ${conversationMemories.length} conversation memories`);
          
          // File details logging
          if (fileMemories.length > 0) {
            fileMemories.forEach((memory, index) => {
              const fileName = memory.metadata?.file_name || memory.metadata?.filename || 'unknown_file';
              const projectId = memory.metadata?.project_id || memory.metadata?.conversation_id || 'unknown_project';
              const isCurrent = projectId === currentProjectId ? 'CURRENT' : 'OTHER';
              const similarity = ((memory.metadata?.similarity || 0) * 100).toFixed(1);
              logger.info(`File ${index + 1}: ${fileName} ${isCurrent} (similarity: ${similarity}%)`);
            });
          }
          
          // CONTEXT BUILDING: Adapt based on strategy
          let contextSections: string[] = [];
          
          if (contextStrategy === 'full' || contextStrategy === 'standard') {
            // FULL CONTEXT for first question or standard follow-ups
            if (fileMemories.length > 0) {
              const priorityFileMemories = fileMemories.slice(0, 6);
              const fileParts = priorityFileMemories.map((memory, index) => {
                const fileName = memory.metadata?.file_name || memory.metadata?.filename || 'archivo_subido';
                const section = memory.metadata?.section || 'contenido';
                const similarity = ((memory.metadata?.similarity || 0) * 100).toFixed(1);
                const chunkInfo = memory.metadata?.chunkIndex !== undefined ? 
                  ` (parte ${memory.metadata.chunkIndex + 1}/${memory.metadata.totalChunks})` : '';
                const projectId = memory.metadata?.project_id || memory.metadata?.conversation_id || 'unknown';
                const isCurrent = projectId === currentProjectId ? 'PROYECTO ACTUAL' : 'OTRO PROYECTO';
                const projectInfo = ` [${isCurrent}]`;
                
                return `**${fileName}** ${chunkInfo}${projectInfo}\nSeccion: ${section}\nRelevancia: ${similarity}%\n\n${memory.content}`;
              });
              
              contextSections.push(`--- ARCHIVOS SUBIDOS (${priorityFileMemories.length} encontrados) ---\n${fileParts.join('\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n')}`);
            }
            
            // Add conversation context if needed
            const maxTotalMemories = 8;
            const usedSlots = Math.min(fileMemories.length, 6);
            const conversationSlots = Math.min(Math.max(maxTotalMemories - usedSlots, 0), 2);
            
            if (conversationMemories.length > 0 && conversationSlots > 0) {
              const priorityConversationMemories = conversationMemories.slice(0, conversationSlots);
              const conversationParts = priorityConversationMemories.map(memory => {
                const similarity = ((memory.metadata?.similarity || 0) * 100).toFixed(1);
                const timestamp = memory.metadata?.timestamp || 'tiempo desconocido';
                return `[${similarity}% similitud | ${timestamp}]\n${memory.content}`;
              });
              
              contextSections.push(`--- CONTEXTO CONVERSACIONAL (${priorityConversationMemories.length} encontrados) ---\n${conversationParts.join('\n\n---\n\n')}`);
            }
          } else if (contextStrategy === 'filtered' || contextStrategy === 'minimal') {
            // FOCUSED CONTEXT for specific follow-up questions
            if (fileMemories.length > 0) {
              const focusedMemories = fileMemories.slice(0, 3); // Reduced number
              const fileParts = focusedMemories.map(memory => {
                const fileName = memory.metadata?.file_name || memory.metadata?.filename || 'archivo_subido';
                const section = memory.metadata?.section || 'contenido';
                return `**${fileName}** - ${section}\n\n${memory.content}`;
              });
              
              contextSections.push(`--- CONTENIDO RELEVANTE ---\n${fileParts.join('\n\n---\n\n')}`);
            }
          }
          
          // Build final context
          if (contextSections.length > 0) {
            contextualMemory = `\n\n${contextSections.join('\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n')}\n\n--- FIN INFORMACION DISPONIBLE ---\n\n`;
            
            logger.info(`Injecting ${contextualMemory.length} characters of context (strategy: ${contextStrategy})`);
            logger.info(`Final summary: ${fileMemories.length} archivos, ${conversationMemories.length} conversaciones`);
          }
        } else {
          logger.info('No relevant context found in any project');
        }
      } else {
        logger.info('Non-file question, skipping file context search');
      }
    } catch (ragError) {
      logger.warn('RAG search failed, continuing without context:', ragError);
    }

    // 7. Build messages for Claude
    const claudeMessages = recentMessages.map(msg => ({
      role: msg.role as 'user' | 'assistant',
      content: msg.content
    }));

    // 8. ‚úÖ ENHANCED: Context injection with DYNAMIC PROMPT SUPPORT
    if (claudeMessages.length > 0) {
      const lastUserIndex = claudeMessages.length - 1;
      if (claudeMessages[lastUserIndex].role === 'user') {
        let baseInstruction = '';
        
        // Build base instruction based on context strategy and settings
        if (isCurrentFileQuestion && contextualMemory) {
          if (contextStrategy === 'full') {
            baseInstruction = `${contextualMemory}\nINSTRUCCION IMPORTANTE: Tienes acceso a archivos que el usuario ha subido al PROYECTO ACTUAL. USA PRIORITARIAMENTE la informacion de estos archivos del proyecto actual para responder. Si la pregunta se refiere a contenido de archivos, cita especificamente de que archivo del proyecto actual proviene la informacion.`;
          } else if (contextStrategy === 'filtered') {
            baseInstruction = `${contextualMemory}\nINSTRUCCION: Ya tienes el contexto del archivo. La pregunta especifica del usuario se refiere a: "${content}". Enfocate en responder especificamente esta nueva pregunta basandote en el contenido mas relevante del archivo.`;
          } else if (contextStrategy === 'minimal') {
            baseInstruction = `${contextualMemory}\nINSTRUCCION: Responde la nueva pregunta especifica del usuario basandote en el archivo que ya conoces del contexto de la conversacion.`;
          } else {
            baseInstruction = `${contextualMemory}\nINFORMACION: Tienes acceso a archivos subidos. Responde basandote en el contenido disponible.`;
          }
        }
        
        // ‚úÖ NEW: Apply custom prompt/template if provided
        let finalInstruction = baseInstruction;
        if (claudeSettings.prompt) {
          finalInstruction = `${baseInstruction}\n\n--- INSTRUCCIONES ADICIONALES ---\n${claudeSettings.prompt}`;
        }
        
        finalInstruction += `\n\nPregunta del usuario:\n${claudeMessages[lastUserIndex].content}`;
        claudeMessages[lastUserIndex].content = finalInstruction;
        
        logger.info(`Applied context injection strategy: ${contextStrategy}${claudeSettings.promptType ? `, promptType: ${claudeSettings.promptType}` : ''}`);
      }
    }

    // 9. ‚úÖ ENHANCED: Send to Claude API with dynamic settings
    const { ClaudeService } = require('./services/claude.service');
    const claudeService = new ClaudeService();
    
    // Validate settings before sending
    const validation = claudeService.validateSettings(claudeSettings);
    if (!validation.valid) {
      logger.warn('Invalid Claude settings provided:', validation.errors);
      res.status(400).json({ error: 'Invalid settings', details: validation.errors });
      return;
    }
    
    logger.info('API Key status: CONFIGURED');
    logger.info('Sending to Claude API with context...');
    console.log('üîç PROMPT DEBUG - Final messages being sent to Claude:');
    console.log(JSON.stringify(claudeMessages, null, 2));
    const claudeResponse = await claudeService.sendMessage(claudeMessages, claudeSettings);
    console.log('üîç CLAUDE RESPONSE DEBUG:', JSON.stringify(claudeResponse, null, 2));
    const assistantContent = claudeResponse.content[0]?.text || 'Sorry, could not generate response.';
    //const assistantContent = claudeResponse.content[0]?.text || 'Sorry, could not generate response.';

    // 10. Save Claude's response with settings metadata
    const assistantMessage = await dbService.addMessage(conversationId, 'assistant', assistantContent, { 
      model: claudeResponse.model,
      usage: claudeResponse.usage,
      context_used: relevantMemories?.length || 0,
      context_strategy: contextStrategy,
      settings_used: claudeSettings // ‚úÖ NEW: Store settings used
    });

    // 11. Store new messages in ChromaDB for future searches
    try {
      const projectId = conversation?.project_id || conversationId;
      
      // Store user message
      await ragService.addMemory(
        projectId, 
        conversationId, 
        content,
        { 
          role: 'user',
          timestamp: new Date().toISOString(),
          conversation_title: conversation?.title || 'Untitled'
        }
      );

      // Store assistant response
      await ragService.addMemory(
        projectId, 
        conversationId, 
        assistantContent,
        { 
          role: 'assistant',
          timestamp: new Date().toISOString(),
          conversation_title: conversation?.title || 'Untitled',
          model: claudeResponse.model
        }
      );

      logger.info('Stored messages in ChromaDB for future context');
    } catch (storageError) {
      logger.warn('Failed to store in ChromaDB:', storageError);
    }

    // 12. ‚úÖ ENHANCED: Respond with configuration info
    res.json({
      user_message: userMessage,
      assistant_message: assistantMessage,
      usage: claudeResponse.usage,
      context_memories_used: relevantMemories?.length || 0,
      context_strategy: contextStrategy,
      settings_applied: claudeSettings // ‚úÖ NEW: Return applied settings
    });

    logger.info(`Message processed successfully. Context memories used: ${relevantMemories?.length || 0}, Strategy: ${contextStrategy}, Settings: ${JSON.stringify(claudeSettings)}`);

  } catch (error) {
    logger.error('Error processing message:', error);
    res.status(500).json({ error: 'Failed to process message' });
  }
});

// Get messages from conversation
app.get('/api/conversations/:id/messages', async (req: express.Request, res: express.Response): Promise<void> => {
  try {
    const conversationId = req.params.id;
    const messages = await dbService.getMessages(conversationId);
    res.json({ messages });
  } catch (error) {
    logger.error('Error fetching messages:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

// Get conversation by id
app.get('/api/conversations/:id', async (req: express.Request, res: express.Response): Promise<void> => {
  try {
    const conversationId = req.params.id;
    const conversation = await dbService.getConversationById(conversationId);
    if (!conversation) {
      res.status(404).json({ error: 'Conversation not found' });
      return;
    }
    res.json(conversation);
  } catch (error) {
    logger.error('Error fetching conversation:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

// ‚úÖ NEW: Endpoint to get available Claude configuration options
app.get('/api/claude/config', async (req: express.Request, res: express.Response): Promise<void> => {
  try {
    const { ClaudeService } = require('./services/claude.service');
    const claudeAPI = new ClaudeService(); // ‚úÖ FIXED: Same variable name pattern
    
    res.json({
      templates: claudeAPI.getPromptTemplates(),
      defaults: claudeAPI.getDefaultSettings(),
      limits: {
        temperature: { min: 0, max: 1, step: 0.1 },
        maxTokens: { min: 100, max: 8000, step: 100 }
      }
    });
  } catch (error) {
    logger.error('Error getting Claude config:', error);
    res.status(500).json({ error: 'Failed to get configuration' });
  }
});

// Health check endpoints
app.get('/api/health', async (req, res) => {
  const ragHealth = await ragService.healthCheck();
  
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
    services: {
      database: 'connected',
      chromadb: ragHealth ? 'healthy' : 'unhealthy'
    }
  });
});

app.get('/api/info', (req, res) => {
  res.json({
    name: 'Claude Infinito v1.1 Backend',
    version: '1.1.0',
    features: ['RAG Integration', 'Persistent Memory', 'Cross-Project Context', 'File Upload Support', 'Intelligent Context Management', 'Dynamic Configuration']
  });
});

app.get('/', (req, res) => {
  res.json({ 
    message: 'Claude Infinito v1.1 Backend - Memory Enabled', 
    status: 'running'
  });
});

app.listen(port, () => {
  logger.info(`Claude Infinito Backend running on port ${port}`);
  logger.info('RAG-enabled memory system active');
  logger.info('File upload integration enabled');
  logger.info('Intelligent context management enabled');
  logger.info('Dynamic configuration support enabled'); // ‚úÖ NEW
});

export default app;

